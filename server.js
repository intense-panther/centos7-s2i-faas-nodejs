const fs   = require('fs'),
      http = require('http'),
      url  = require('url');

// TODO: better logging

var functionsFile;
if (fs.existsSync('package.json')) {
  functionsFile = JSON.parse(fs.readFileSync('package.json')).main;
}

const functions = require("./" + (functionsFile === undefined ? 'index.js' : functionsFile));

const currentTime = () => Date.now();

const isType = (o, t) => typeof(o) === t;

const server = http.createServer(function(request, response) {

  // TODO: make configurable
  const timeout = 500;
  var timeoutTimer;

  const respond = (status, body) => {
    if (timeoutTimer !== undefined) {
      clearTimeout(timeoutTimer);
      timeoutTimer = null;
    }

    if (response.finished) {

      return;
    }

    var content;
    if (body !== undefined) {
      try {
        content = JSON.stringify(body);
      } catch (e) {
        //TODO: log error
        status = 502;
        content = e;
      }
    }

    if (status === undefined) {
      status = 200;
    }
    response.statusCode = status;

    if (content != undefined) {
      response.setHeader('Content-Type', 'application/json');
      response.write(content);
    }

    response.end();
  };

  // TODO: better error message?
  response.on('error', (e) => console.error(e));

  const errHandler = (ex) => {
    console.log(`Error invoking '${fName}': ${ex}`);
    respond(502, `Error invoking function '${fName}'`);
  };

  const fName = url.parse(request.url).pathname.split('/')[1];
  if (fName === undefined ||
      fName.length === 0) {
    respond(400, "No function name provided");

    return;
  }

  const fn = functions[fName];
  if (fn === undefined) {
    respond(404, `No fn named '${fName}' available`);

    return;
  }

  const body = [];

  request.
    on('error', errHandler).
    on('data', (d) => body.push(d)).
    on('end', () => {
      // A possible approach:
      // read the body
      // if the content-type is present
      //   if it is json, read as json
      //   if it is text, read as string
      //   if it is form params, read into an object
      //   else respond with error
      // else
      //   try to read as json
      //   catch and respond with error
      //
      // but for now, assume all is json:
      var event;
      try {
        const strBody = Buffer.concat(body).toString();
        if (strBody.length > 0) {
          event = JSON.parse(strBody);
        }   
      } catch (e) {
        console.error(e);
        respond(400, e);

        return;
      }

      const context = {
        functionName: fName,
        remainingTime: () => startTime + timeout - currentTime()
        // TODO: more context, like config/secrets/etc
        // TODO: also a request ID, generated by the router(?) and used
        // when logging
      };

      const startTime = currentTime();
      timeoutTimer = setTimeout(respond, timeout, 504, `Invoking function '${fName}' timed-out after ${timeout}ms`);

      var retVal;
      try {
        retVal = fn(event, context);
      } catch (ex) {
        errHandler(ex);

        return;
      }

      const respond200 = (body) => respond(200, body);

      if (isType(retVal.then, "function")) {
        retVal.then(respond200).catch(errHandler);
      } else {
        respond200(retVal);
      }
    });
});

server.listen(8080);
console.log("Listening on 8080");
